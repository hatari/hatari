/*
  Hatari - gui_event.c

  SPDX-License-Identifier: GPL-2.0-or-later

  User interface (SDL) event handling
*/

#include "main.h"

#if ENABLE_SDL3
#include <SDL3/SDL.h>
#else
#include <SDL.h>
#endif

#include "configuration.h"
#include "control.h"
#include "conv_st.h"
#include "gui_event.h"
#include "ikbd.h"
#include "keymap_sdl.h"
#include "log.h"
#include "screen.h"
#include "screen_sdl.h"
#include "shortcut.h"
#include "statusbar_sdl.h"
#include "video.h"


static bool bIgnoreNextMouseMotion = false; /* Ignore next mouse motion (needed after SDL_WarpMouse) */
static bool bAllowMouseWarp = true;         /* disabled when window loses mouse pointer / key focus */


/**
 * Set mouse pointer to new x,y coordinates and set flag to ignore
 * the mouse event that is generated by SDL_WarpMouse().
 *
 * Skip the request if:
 * - it's not position restore and mouse warping is disabled, or
 * - mouse warp disable due to mouse leaving Hatari window or focus loss
 *   (i.e. user isn't interacting with it)
 */
void GuiEvent_WarpMouse(int x, int y, bool restore)
{
	if (!(restore || ConfigureParams.Screen.bMouseWarp))
		return;
	if (!bAllowMouseWarp)
		return;

	SDL_WarpMouseInWindow(sdlWindow, x, y);
	bIgnoreNextMouseMotion = true;
}


/**
 * Handle mouse motion event.
 */
static void GuiEvent_HandleMouseMotion(int dx, int dy)
{
	static int ax = 0, ay = 0;

	/* Ignore motion when position has changed right after a reset or TOS
	 * (especially version 4.04) might get confused and play key clicks */
	if (bIgnoreNextMouseMotion || nVBLs < 10)
	{
		bIgnoreNextMouseMotion = false;
		return;
	}

	/* In zoomed low res mode, we divide dx and dy by the zoom factor so that
	 * the ST mouse cursor stays in sync with the host mouse. However, we have
	 * to take care of lowest bit of dx and dy which will get lost when
	 * dividing. So we store these bits in ax and ay and add them to dx and dy
	 * the next time. */
	if (nScreenZoomX != 1)
	{
		dx += ax;
		ax = dx % nScreenZoomX;
		dx /= nScreenZoomX;
	}
	if (nScreenZoomY != 1)
	{
		dy += ay;
		ay = dy % nScreenZoomY;
		dy /= nScreenZoomY;
	}

	if (!bInFullScreen)			/* Consider window scaling? */
	{
		static int wx, wy;
		int win_width, win_height, ndx, ndy;

		SDL_GetWindowSize(sdlWindow, &win_width, &win_height);

		if (sdlscrn->w != win_width)
		{
			ndx = dx * sdlscrn->w;
			dx = (ndx + wx) / win_width;
			wx = (ndx + wx) % win_width;
		}
		if (sdlscrn->h != win_height)
		{
			ndy = dy * sdlscrn->h;
			dy = (ndy + wy) / win_height;
			wy = (ndy + wy) % win_height;
		}
	}

	KeyboardProcessor.Mouse.dx += dx;
	KeyboardProcessor.Mouse.dy += dy;
}


/**
 * SDL message handler.
 * Here we process the SDL events (keyboard, mouse, ...) and map it to
 * Atari IKBD events.
 */
void GuiEvent_EventHandler(void)
{
	bool bContinueProcessing;
	SDL_Event event;
	int events;
	int remotepause;
	static int mleave_x = -1, mleave_y = -1;

	do
	{
		bContinueProcessing = false;

		/* check remote process control */
		remotepause = Control_CheckUpdates();

		if ( bEmulationActive || remotepause )
		{
			events = SDL_PollEvent(&event);
		}
		else
		{
			ShortCut_ActKey();
			/* last (shortcut) event activated emulation? */
			if ( bEmulationActive )
				break;
			events = SDL_WaitEvent(&event);
		}
		if (!events)
		{
			/* no events -> if emulation is active or
			 * user is quitting -> return from function.
			 */
			continue;
		}
		switch (event.type)
		{
		 case SDL_QUIT:
			Main_RequestQuit(0);
			break;

		 case SDL_KEYDOWN:
			if (event.key.repeat)
			{
				bContinueProcessing = true;
				break;
			}
#if ENABLE_SDL3
			Keymap_KeyDown(event.key.mod, event.key.key,
			               event.key.scancode);
#else
			Keymap_KeyDown(event.key.keysym.mod, event.key.keysym.sym,
			               event.key.keysym.scancode);
#endif
			break;

		 case SDL_KEYUP:
#if ENABLE_SDL3
			Keymap_KeyUp(event.key.mod, event.key.key,
			             event.key.scancode);
#else
			Keymap_KeyUp(event.key.keysym.mod, event.key.keysym.sym,
			             event.key.keysym.scancode);
#endif
			break;

		 case SDL_MOUSEMOTION:               /* Read/Update internal mouse position */
			GuiEvent_HandleMouseMotion(event.motion.xrel, event.motion.yrel);
			bContinueProcessing = true;
			break;

		 case SDL_MOUSEBUTTONDOWN:
			if (event.button.button == SDL_BUTTON_LEFT)
			{
				if (Keyboard.LButtonDblClk == 0)
					Keyboard.bLButtonDown |= BUTTON_MOUSE;  /* Set button down flag */
			}
			else if (event.button.button == SDL_BUTTON_RIGHT)
			{
				Keyboard.bRButtonDown |= BUTTON_MOUSE;
			}
			else if (event.button.button == SDL_BUTTON_MIDDLE)
			{
				/* Start double-click sequence in emulation time */
				Keyboard.LButtonDblClk = 1;
			}
			break;

		 case SDL_MOUSEBUTTONUP:
			if (event.button.button == SDL_BUTTON_LEFT)
			{
				Keyboard.bLButtonDown &= ~BUTTON_MOUSE;
			}
			else if (event.button.button == SDL_BUTTON_RIGHT)
			{
				Keyboard.bRButtonDown &= ~BUTTON_MOUSE;
			}
			break;

		 case SDL_MOUSEWHEEL:
			/* Simulate cursor keys on mouse wheel events */
			if (event.wheel.x > 0)
			{
				IKBD_PressSTKey(0x4d, true);
				IKBD_PressSTKey(0x4d, false);
			}
			else if (event.wheel.x < 0)
			{
				IKBD_PressSTKey(0x4b, true);
				IKBD_PressSTKey(0x4b, false);
			}
			if (event.wheel.y < 0)
			{
				IKBD_PressSTKey(0x50, true);
				IKBD_PressSTKey(0x50, false);
			}
			else if (event.wheel.y > 0)
			{
				IKBD_PressSTKey(0x48, true);
				IKBD_PressSTKey(0x48, false);
			}
			break;

#ifndef ENABLE_SDL3
		 case SDL_WINDOWEVENT:
			Log_Printf(LOG_DEBUG, "SDL2 window event: 0x%x\n", event.window.event);
			switch(event.window.event) {
#endif
			case SDL_WINDOWEVENT_EXPOSED:
				if (!ConfigureParams.Screen.bUseSdlRenderer)
				{
					/* Hack: Redraw screen here when going into
					 * fullscreen mode without SDL renderer */
					sdlscrn = SDL_GetWindowSurface(sdlWindow);
					ConvST_SetFullUpdate();
					Statusbar_Init(sdlscrn);
				}
				/* fall through */
			case SDL_WINDOWEVENT_RESTORED:
				/* Note: any changes here should most likely
				 * be done also in sdlgui.c::SDLGui_DoDialog()
				 */
				Screen_UpdateRect(sdlscrn, 0, 0, 0, 0);
				break;
			case SDL_WINDOWEVENT_SIZE_CHANGED:
				/* internal & external window size changes */
				Screen_SetTextureScale(sdlscrn->w, sdlscrn->h,
						       event.window.data1,
						       event.window.data2, false);
				Screen_UpdateRect(sdlscrn, 0, 0, 0, 0);
				break;
				/* mouse & keyboard focus */
			case SDL_WINDOWEVENT_ENTER:
				if (mleave_x != -1)
				{
					int new_x, new_y;
					Screen_GetMouseState(&new_x, &new_y);
					GuiEvent_HandleMouseMotion(new_x - mleave_x,
					                           new_y - mleave_y);
					mleave_x = mleave_y = -1;
				}
				/* fall through */
			case SDL_WINDOWEVENT_FOCUS_GAINED:
				bAllowMouseWarp = true;
				break;
			case SDL_WINDOWEVENT_LEAVE:
				Screen_GetMouseState(&mleave_x, &mleave_y);
				/* fall through */
			case SDL_WINDOWEVENT_FOCUS_LOST:
				bAllowMouseWarp = false;
				break;
#ifndef ENABLE_SDL3
			}
			bContinueProcessing = true;
			break;
#endif

		 default:
			/* don't let unknown events delay event processing */
			bContinueProcessing = true;
			break;
		}
	} while (bContinueProcessing || !(bEmulationActive || bQuitProgram));
}
